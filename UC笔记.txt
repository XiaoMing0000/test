wait()和waitpid()区别：
	wait()是等待任意子进程的结束，等待过程 父进程阻塞。
	waitpid()可以等待制定的子进程结束（也可以任意），等待过程中，父进程可以阻塞，
也可以不阻塞。
	pid_t waitpid(pid_t pid, int * status, int options)
	第二个参数和返回值与wait一样，参数pid可以指定等待哪个/哪些子进程。
	options可以指定等待时是否阻塞
	pid的值：
		-1 等待任一子进程结束
		>0 等待特定的子进程结束（子进程PID = pid）
		0  等待 本进程组的 子进程结束
		<-1 等待 进程组ID等于pid绝对自的子进程
		注：-1 和 >0 常用，后面两个了解即可。
	options的值：
		0 代表阻塞
		WNOHANG 代表非阻塞
		注：如果options用了WNOHANG，返回值有三种：
			正数：等待到结束的子进程PID
			0	：没有子进程结束，直接返回
			-1	：出错了。
	注：exit()不论参数是多少，都是正常结束的进程但，一般用负数代表 没有完成
	相关的功能。
	
	创建子进程有两种方式：
	1 fork() - 复制父进程，创建子进程
	2 vfor()+execl() - 全新的子进程
	
	vfor()从语法上看，和fork()一样。但机制和fork()完全不同。
	vfor()不会复制父进程的任何资源，子进程会占用父进程的资源运行，父进程阻塞；
直到子进程用exec系列函数（比如：execl）或者子进程结束，资源就会还给父进程。
	vfork()只能创建新进程，不能提供程序。
	execl()只能提供程序，不能创建新的进程。
	vfork()+ececl()既有进程，又有执行的程序。
	vfork()常创建的子进程一定优先于父进程运行，直到子进程运行了execl()函数才能同时运行。
	vfork()创建的子进程，如果不调用execl()，必须用exti()强行退出，否侧死循环（引发段错误）。
	execl() 函数负责启动一个全新的程序，格式：int execl(char * path, char * cmd, …)
		第一个参数是程序所在的路径（目录/程序名）；第二个参数是执行程序的命令；… 代表0-n个
	任意参数，一般可以跟选项，参数等，最后以 NULL 结束；失败返回-1。失败就意味着，，没有启
	动新程序。
		注：execl()函数不会改变进程的PID，只会改变进程执行的代码（全新的程序）。
		
	Unix信号和Linux信号不同，Linux0-64，中间不连续，Unix0-48。此外，有些信号对应的值也
不相同。编程是尽量使用信号的宏名称，而不要用值。
	信号是异步处理方式，无法判断信号什么时候来，因此无法知道什么时候处理信号。
	信号0 特殊用途，本身不代表任何的事件，也不会处理，用于测试 是否有权限发信号。
进程之间可以互发信号但受到用户权限影响。用户只能给自己的进程发信号，其他用户的进程不
能发。root可以给所有进程发信号。
	程序收到信号以后的处理方式：
		1 默认处理方式，80%都是 退出进程。
		2 忽略信号，不做任何处理。
		3 程序员可以自定义信号的处理方式，只需要写一个信号处理函数。
		信号9 不能被忽略，也不能自定义。
	信号处理的实现步骤：
		1 写一个信号处理函数
		2 用signal()/sigaction()注册信号处理方式
回顾：
	进程管理 - wait()、waitpid()
	可以让父进程等待子进程的结束，并负责获取子进程的退出信息。
	waitpid()可以有更多的选着。（可以选择是否阻塞、等待哪个/哪些进程）
	进程创建的第二种方法：vfork()+execl()
	子进程执行的全新的代码（与父进程无关）
	信号 - 信号就是用来做中断的，属于软件中断
		服务器集群：负载均衡、内存复制
	信号分类：可靠信号和不可靠信号
		信号处理方式 1默认 2忽略 3自定义处理函数
		1 不设置走默认处理
		2 用signal()/sigaction()可以设置
	进程从启动	就有一个信号总表，总表里面是默认的处理
帅的惊动党

	关于子进程创建的处理
		如果创建子进程，fork()创建的子进程完全沿袭父进程对信号的处理方式。
		vfork()+execl()创建的子进程，父进程默认子进程也默认，父进程忽略子进程也忽略，
	父进程自定义处理函数子进程默认。
day11	信号	
总结发送信号的方式：
	1 键盘发送信号（部分信号）
		ctrl+c -> 信号2 SIGINT
		ctrl+\ -> 信号9 SIGQUIT
	2 出错（部分信号）
		整数0   -> 信号8 SIGFPE
		段错误  -> 信号11 SIGSEGV
		总线错误-> 信号7 SIGBUS
	3 kill命令（全部信号）
		kill -信号 进程ID
		killall name	//删除名称为name的所有进程
	4 信号发送函数
		raise() - 给本进程发任意信号
		kill() - 给任意进程（进程组）发任意信号
		alarm() - 给本进程发发特定信号（闹钟）
		sigqueue() - 给任意进程发任意信号，可以附带额外的数据（少用）
		
	主讲kill(), 了解alarm()
	int kill(pid_t pid, int signo)
		参数：pid 制定发给哪个/哪些进程
				signo 就是发送的哪个信号
			整数 - 给进程ID=pid的特定进程发信号
			-1	 - 给多有有权限的进程发信号
			0	 - 给本进程组的进程发信号
			<-1	 - 给进程组ID=-pid的进程发送信号。
	alarm(参数n) - n秒之后产生一个闹钟信号 SIGALRM
	sleep(int n)可能休眠n秒，也可能被非忽略的信号打断，并返回剩余秒数。
	usleep()是微妙级的休眠函数（man手册有一些不准确）
	类型：long long int标C的64位整数
		32位有符号整数 大致范围：正负21亿
		0x80000000 到 0x7FFFFFFF
	信号集
		信号集就是 信号的集合，可以理解成一个超大的整数（为了操作系统的扩展性）。
	用一个二进制位对应一个信号。最后一位代表信号1，如果最后一位是1，代表信号集中有
	信号1，如果是0， 就没有信号1。
		信号集是类型sigset_t 。
	数据结构 - 数据结构包括：
		1 集 元素之间没有任何关系
		2 线性结构 元素之间是最后一对的关系
		3 树形结构 元素之间是一对多的父子关系
		4 网状结构 元素之间是多对多的网格关系
	物理结构：
		线性和链式表
	运算结构：
		1 创建和删除
		2 增加元素和删除元素
		3 修改和查找
		4 排序和其他算法
	关于数据结构sigset_t，需要提供基本的函数如下：
		1 增加元素
			sigaddset() - 增加一个信号
			sigfillset() - 放入所有信号（全部增加）
		2 删除信号
			sigdelset() - 删除一个信号
			sigemptyset() - 清空信号集（全部删除）
		3 查找信号
			sigismember() - 判断信号是否存在
	信号屏蔽
		在执行一些关键代码是，进程需要屏蔽一些信号，防止 信号中断关键代码。
		信号屏蔽 无法保证信号不来，但信号可以暂时不做处理，不会中断关键代码。等关键代码
	执行完毕后，解除信号屏蔽再中断代码执行信号的处理函数。
	函数sigprocmask()
		sigprocmask(int how, sigset_t * newset, sigset_t * oldset);
			参数：newset 代表新的需要屏蔽的信号
					oldset 用于传出旧的信号屏蔽（不用传出给0或空）
					how 是运算的方式：
						SIG_BOLCK 新的+旧的， 	比如：ABC+CDE -> ABCDE
						SIG_UNBLOCK 旧的-新的	比如：ABC-CDE -> AB
						SIG_SETMASK 直接使用新的，不考虑旧的 比如：ABC和CDE -> DE
					注：how就选择SIG_SETMASK即可。
今天：
	IPC - 进程间通信 （两个进程数据交互）
		了解信号里面的一个计数器
	计时器包括三种
		真实计时器、虚拟计时器和实用计时器。
		最常见的是真实计时器。
		设置计时器函数setitimer()。
	IPC - 进程间通信
		进程间通信方式：
			1 文件
			2 信号
			3 管道
			4 共享内存
			5 消息队列
			6 信号量集（semaphore）
			7 网络（套接字socket）
			……
		其中，共享内存、消息队列和信号量集遵守相同的规范，加XSI IPC，最重要的是消息队列。
		IPC的应用基本上遵循一个固定套路，在编程时只需要按照固定的步骤调用相应函数即可。
		
		管道(pipe)的交互媒介是一种特殊的文件：管道文件的常见必须mkfifo命令/mkfifo()，
	touch不能创建管道文件。管道文件的后缀是 .pipe
		管道只做交互的媒介，不存储数据。因此只有在输入输出都存在是，才畅通，否则就卡住。

	XSI IPC - 共享内存、消息队列和信号量集
	XSI IPC 遵守相同的规范，因此用法非常类似。
	共同的使用方法：
		1 创建时都需要使用key，key是一个整数，外部程序使用key来获取内核中的IPC结构（共享内
	内存、消息队列和信号量集 也就是交互的媒介）。
		2 key的生成方式有三种：
			a 宏IPC_PRIVATE 直接做key，这种基本不使用，只能创建IPC结构，别的进程不能调用。
			b 可以定义一个头文件，把所有的key写在头文件中。
			c 函数ftok() 可以用一个真实存在的目录和一个人工分配的项目ID(0-255)自动生成一个key
		3 所有IPC在内核中对应一个唯一的ID，标识每个IPC结构。
		4 key是用来查找ID的，ID是用来定位IPC结构的。
			函数xxxget()，比如：shmget(key, ...)/msgget(key, ...)可用key取得ID，后续的代码使
		用ID即可。
		5 创建IPC结构时，都需要提供一个flags参数，这个参数一般是：
			0666|IPC_CREAT|IPC_EXCL
			权限   创建		如果存在，直接返回-1
		6 每种IPC结构都需要一个操作函数xxxctl()，它至少包括以下功能：
			a IPC_STAT：取IPC结构的相关属性（查看）
			b IPC_SET：修改IPC结构的部分属性
			c IPC_RMID：删除IPC结构
			注：IPC结构由 内核管理，因此如果不删除，重启机器后依然存在。用完记得删除。
		关于IPC相关的命令：
			ipcs - 查看opc结构
				-a 显示所有共享内核对象
				-m 显示共享内存		m=memory
				-q 显示共享队列		q=queue
				-s 显示信号量		s=semaphore
			ipcrm - 删除ipc
				-m ID 删除共享内存
				-q ID 删除共享队列
				-s ID 删除信号量
	1 共享内存
		共享内存是以 一块内存 作为IPC交互的媒介，这块内存由内核维护和管理，允许其他进
	程映射。IPC中共享内存效率高。共享内存最大的问题就是多个进程同时修改很难控制。
		共享内存的步骤：
			1 创建key，可以使用头文件定义或ftok().
			2 使用shmget(key, ...)用key创建/获取共享ID。
			3 使用shmat(ID)挂接(映射)共享内存。
			4 正常使用
			5 使用shmdt()脱接(解除映射)共享内存。
			6 如果确保不再使用，可以删除共享。shmctl(IPC_RMID)
	2 消息队列
		数据封入消息中，把消息放入队列中。队列由内核负责创建和维护。
		消息队列的使用步骤：
			1 用ftok()或头文件定义方式 生成key。
			2 用key创建/获取 消息队列的ID。 msgget(key, ...)
			3 放入消息/取出消息
				msgsnd() -> 放入、发送消息
				msgrcv() -> 取出、接收消息
			4 如果确保不再使用消息队列，需要删除。
				msgctl(msgid, IPC_RMID, ...)
	关于消息：
		消息分为有类型消息和无类型消息：
			无类型消息，消息 == 数据，可以使用任意类型，比如：可以是int、double、
		字符串、结构、联合。这种消息 严格 遵守先入先出。
		有类型消息，消息 = 数据+消息类型，必须是结构体，格式如下：
			struct 消息名可以随便
			{
				long mtype; 	//第一个成员必须是消息类型
				...//后面 随便写，是数据。
			}
			其中，mtype必须大于0
			msgsnd() 发送有类型消息时，没有特殊要求。
			msgrcv()接收有类型消息时，可以用第四个参数选择接收消息的类型。
		第四个参数flags可能的值：
			1. 整数	接收指定类型的值
			2.  0	接收任意类型的消息（先进先出）
			3. 负数	接收小于等于flags绝对值的消息，次序先小后大。
	
	IPC - 进程通信
	Unix系统很多东西是建立进程基础上的，多个进程之间需要交互数据，进程之间的数据
交互叫IPC。Unix系统大量使用IPC技术。
	IPC主要方法：
		1 文件
		2 信号
		3 管道
		4 共享内存
		5 消息队列
		6 信号量集
		7 网络socket
		.....
	共享内存和消息队列的使用步骤：
		1 共享内存的编程步骤：
			1 使用ftok()或头文件 获取key。
			2 使用shmget(key, ...)创建/获取 共享内存
			3 使用shmat(shmid, ...)映射 共享内存
			4 正常使用
			5 使用shmdt(void *)解除对共享内存的映射
			6 若果不在使用，用shmctl(shmid, IPC_RMID)从内核中删除共享内存（彻底删除）
			注：只有挂接数为0的共享内存才能删除，否则只会做一个删除的标记，直到挂接数为0的
		时候才真正的删除。
		时候才真正的删除。
		2 消息队列的编程步骤
			1 使用ftok()或定义头文件生成key。
			2 使用msgget(key, ...)创建/获取消息队列。
			3 往队列中存入/取出消息
				msgsnd() - 放入消息
				msgrcv() - 取出消息
				在取出消息时，可以按照消息的类型有选择的取出消息。
			4 如果如果确保不再使用消息队列，使用msgctl()删除消息队列。
			注：在使用有类型消息时，第二个参数地址是整个结构的地址，但第三个参数大小只是
		数据区的大小（不包括消息类型mtype）。
		
		资源的管理 遵循 谁创建谁回收的基本原则。
	
综合案例1：模拟银行ATM
	银行ATM的提供功能：
		开户、销户、存钱、取钱、查询余额、转账。
		今天主做开户功能，基础好的都做。
		开户的流程：
			账户定义一个结构，包括以下信息：
				ID、用户名、密码、钱数
				卡号ID系统系统，用户名、密码和钱数用户输入。
				1 用户登录客户端，选择功能、选择开户后、输入用户名、密码、钱数，把数据
			封在消息中，放入消息队列中。
				2 服务端从消息队列中消息，生成一个ID，然后把用户的账户写入文件中，并返
			回是否成功给客户端。
				3 客户端收到服务器的返回，给出操作的结果。
		思路：
			1 先定义一个结构，用来代表账户信息。
			2 在定义一个消息结构Msg，第二个参数用账户结构。
			3 定义一些列的宏，代表消息类型，每种消息类型对应一种操作/操作结果（8个宏。）
				以上 3 个定义在头文件中。
			4 至少写两个程序，一个客户端（有界面），另外一个是服务器。
			5 创建 2 个消息队列，一个用于客户端发服务器，另外一个用于 服务器发客户端。
			6 服务器应该先启动，启动后在死循环中接收客户端发来的消息。收到消息后，按消息
		的类型决定如何处理 ，并把结果封装在消息中，吧结果放入另一个消息队列中
			7 客户端启动后先显示界面，选择功能后，输入必须要信息后，把数据封装消息中，放
		入消息队列，并等服务器的回发消息。
		
		两个问题ID？
			如何生成无重复的系统账户ID？
				实现一个计数累加的功能。
					先创建一个文件，写一个初始值进去。
			保存用户信息时，可以一个账户一个文件（首选）。也可以所有账户一个文件。
	
信号量集（semaphore arrays)
	信号量集和信号没有关系，是一个信号量的数组。
	信号量是一个计数器，用于控制访问共享资源的大并行进程/线程总数。
	加入信号量3， 有5个进程：1先上，结束 2 3 4同时上，结束2，5再上。
	计数器的工作方式：
		1 自增行，开始计数0， 来一个 自增1， 走一个自减1，到计数最大值 不允许再来。
		2 自减型，开始计数就是最大值，来一个自减1，走一个自增1，计数到0 不允许再来
	再来就阻塞，直到有其他进程结束，计数不再是0。
	如果进程需要访问多个共享资源，需要多个计数器，而多个计数器就是用 信号量集（信号
量数组）。
	信号量集其实是进程间都调度，并不真正的互发数据。
	信号量集的编程步骤：
		1 使用ftok()或头文件 生成key。
		2 使用semget(key, ...)创建/获取信号量集
		3 使用semctl(semid, ...)给每个信号集中的每个信号量赋值（给数组中的每个元素）。
		4 使用信号量semop()
		5 如果不再使用，可以使用semctl()删除。
	函数注解：
		semctl()初始化信号量集中的每个信号量，将格式：
		semctl(semdi, int  index, int cmd, ...)
		如果cmd取 SETVAL，可以给一个信号量赋初始值。index是该信号量的下标，第四个参
	数就是初始值。比如：
		semctl(semid, 0, SETVAL, 5) 给第一个信号量最大计数设置为5
		semop(int semid, struct sembuf sempoarray[], size_t nops); 就是用于计数的加1
	和减1.
			参数semoparray是一个个指针，它指向一个信号量操作数组，
			信号量操作由sembuf结构表示：
			struct sembuf{
				unsigned sem_num;	//操作信号量的下标
				short sem_op;		//信号量操作方式。负数，0，整数
				short sem_flg;		//计数到0是否阻塞，为0就阻塞，为IPC_NOWAIT不阻塞
			};
			如果sem_op为正，则对应于进程释放占用的资源数，sem_op值加到信号量上，如果
		undo标志（sem_flg成员设置了SEM_UNDO位），则也从该进程的此信号中减去sem_op，
		若sem_op为负，则表示要获取该信号量控制的资源

网络编程
	网络的常识 - 程序员需要知道关于网络的一些基本常识。最主要的是IP地址和端口。
	网络编程 - TCP编程 和 UDP编程。
		OSI 七层模型：
				Upper Layers	高三层
		1	Application		应用层			
		2	Presentation	表现层			
		3	Session			会话层  			
				Lower Layers	第四层
		4	Transport		传输层			TCP/IP
		5	Network			网络层			
		6	Data Link		数据链路层			
		7	Physical		物理层	
	TCP（Transmission Control Protocol）传输控制协议，基于连接的服务
	UDP（User Datagram Protocol） 用户数据报协议，无连接的服务
	IP （Internet Protocol） Internet协议，信息传输机制。
	TCP/IP的模型：
		把会话、表现和应用层 统称为大应用层。
		传输层和网络层不变
		物理层和数据链路层 可以合也可以分
		
		协议和协议簇
			协议就是数据传输的方式和准则，一系列相关的协议组组成协议簇，协议簇一般
		以最核心的协议命名。协议簇在某些资料上写成 协议族。
	常见协议：
		TCP - 传输控制协议，一般不翻译。传输层
		IP  - 网络协议，一般不翻译。	网络层
		UDP - 用户数据报协议。传输层
		HTTP- 超文本传输协议
		FTP - 文件传输协议（上传和下载）
		收发邮件协议
		……
	Socket编程的概念
		流（Stream）
		连接（Connection）
		阻塞（Block）、非阻塞（Non-block）
		同步（Synchronous）、异步（asynchronous）
		IP地址
		字节顺序
	IP地址是Internet中唯一的地址标识，
		-IP地址是一个32位长（正在扩充到128位）
		-每个Internet包必须带IP地址
	点分十进制表示法
		将IP地址的4个字节的数字用十进制表示并用点隔开，如：202.122.58.200（0xCA703AC8)
	IP地址的分级
	子网掩码（Subnet Mask）
	IP地址是计算机 在网络中的唯一标识，可以定位网络中的计算机。
	IP地址本质上是一个整数，分IPv4和IPv6，IPv是主流，占32位（4字节）。IPv6占128位。
	IP地址有两种表现形式：
		底层就是一个32位的整数，用8位十六进制标识
		点分十进制，每个字节转成一个十进制数，中间用 . 分割。
	计算机更喜欢8位十六进制，而人更喜欢点分十进制，但在底层都是存的32位二进制。
这两种表现方式可以进行转换。
		比如：192.168.100.17 和 0xC0A86411 标识相同
	C语言也提供了转换函数。
	IP地址工作原理：
		IP地址需要和网卡的地址绑定才能定位计算机，每块网卡的地址是出厂就设定好的，
	无重复，叫物理地址（MAC地址）。
	
	子网掩码用于区分两个IP地址是不是在一个子网中。
		166.111.160.1与 166.111.161.48
		子网掩码：255.255.254.0
		IP和子网掩码做位与运算，结果一样的是一个子网。
		166.111.160.1
		255.255.254.0（位与）
		166.111.160.0
	
		166.111.161.45
		255.255.254.0（位与）
		166.111.160.0 -> 是一个局域网
	IP地址只能找到计算机，但对应不了计算机中的进程，端口号负责负责对应计算机中的
某个进程。
	端口就是计算机中某个进程的网络标号，只有ip+端口 才能数据交互。
	端口也是一个整数，short类型， 0-65535。
	端口的分类：
		0-1023 最好不要使用，系统使用其中的一部分。
		1024-48XX 正常使用的端口，有很少的部分会被某些安装的软件使用个，比如：1521 
	Oracle数据库。
		48000 以后的，动态端口，不稳定。
		字节顺序：不同的机器存储整数时，存放方式不同。
		比如：某个整数的4个字节分别是A B C D，有些机器是按A B C D方式存储，而还有一
	些机器是D C B A。
		整数的存储顺序有本机格式和网络格式之分，本机格式的字节顺序不确定，而网络格式
	的字节顺序是确定的。如果想要端口号正确传输，需要把本机格式转换网络格式。
	
	ping命令可以查看网络是否畅通。屏后面跟IP地址或域名。
	
	网络编程在C语言中叫Socket编程。（开发）
	网络编程其实就是网络版的 进程间通信（IPC）
	socket编程分本地通信（IPC）和网络通信
day15：网络编程
	Unix/Linux系统作为服务器操作系统存在至今，因此Unix的网络功能应该是非常全面和
强大的。
	网络编程其实有很熟悉的套路，并且Windows也能通用。
	网络编程又叫socket编程，socket本意是插座
	socket编程 分为本地通信和网络通信，本机通信由于其他IPC的存在，已经很少使用。重
点是网络通信。
	网络编程至少要写2个程序，服务器端和客户端，因此编程时需要考虑两端的程序。
	socket(套接字)编程步骤：
		1 服务端
			1.1 创建一个socket，使用函数socket()
			int socket(int domain, int type, int protocol)
			参数：domain 域，用来选择协议簇
					PF_NUIX/PF_LOCAL/PF_FILE：本地通信IPC
					PF_INET：网络通信（IPv4）
					PF_INTE6：网络通信（IPv6）
					注：PF也可以写成AF
				type 用于选择通信类型
					SOCK_STREAM：数据流（TCP）
					SOCK_DGRAM： 数据报（UDP）
				protocol：已经没有意义了，因为协议已经被前两个参数决定，所以给0即可。
			返回 socket描述符，出错分会-1
			1.2 准备通信地址（搞文件/IP端口）
				有三个通信地址：
					struct sockaddr：不存数据，专门做参数
					struct sockaddr_un：存储本地通信的数据，本地通信使用一个文件做
				IPC媒介，因此存储了socket文件名（.sock）。
						#include<sys/un.h>
						struct sockaddr_un{
							int sun_family;		//协议簇
							char sun_path[];	//文件名(带路径)
						}
				struct sockaddr_in：存储网络通信数据
				#include<sys/in.h>
				struct sockaddr_in{
					int sin_family;		//协议簇
					short sin_port;		//端口号
					struct in_addr sin_addr;	//IP地址
				}
			1.3 绑定（描述符和通信地址）
				bind(sockfd, sockaddr, sizeof(addr));
				绑定其实就是服务器对外开放一个端口
			1.4 通信（reat()/write()）
				使用读写文件描述符的方式读写socket描述符
			1.5 关闭socket描述符
		2 客户端：
			步骤与服务器完全一样，除了第三个步把bind()换成connect()即可。
			注：connect()的参数和bind()完全一样，但bind()中提供的是服务器的ip端口，
		connect()中提供的是服务器的ip端口。
			如果服务器在读，客户应该写。
	注：使用网络编程时，网络通信地址中的IP和端口都需要转换函数：
		inet_addr() - 转点分十进制的IP为整数IP
		htons() - 转端口号的本机格式为网络格式

	以上写的是典型的1对1的模式，商业开发更多使用的是 基于TCP和基于UDP的开发模式。
	TCP是有连接协议，所有操作 基于 客户端和服务器保持连接，会重发一切的错误数据。
	
	TCP协议一对多编程步骤：
		1 socket() 获取一个socker描述符。
		2 准备通信地址。
		3 bind()绑定
		4 监听listen()，可以设置多个客户同时访问时，只能操作一个，其它放入队列中。
	listen()用户设置队列的最大长度。
		5 等待客户端的连接 accept()
			int accept(int sockfd, sockaddr* addr, socklen_t *len)
			参数：	sockfd 就是第一步的返回值。
					addr是用于接收连接的客户端通信的地址
					len 是传入传出参数，先传入通信地址的大小，在传出获取到的客户端
				通信地址的大小。
			返回值：返回新的描述符，用于和客户端的读写通信。
		6 读写
		7 关闭socket描述符
		客户端不需要做出任何的改变。
		
	改良服务器的代码，改成可以为多个客户端服务的。（加无限循环，退出时用信号）
	
UDP的编程
	UDP协议 - 无连接协议，不保证连接。因此UDP不保证数据的完整和正确，因为不会重发
错误数据。
	TCP 占用资源大，但保证数据正确完整。
	UDP 占用资源少，但不保证数据正确完整。
	
	UDP无连接协议，但也可以建立UDP连接。
	
	SOCK_STREAM : 数据流（用于TCP）
	SOCK_DGRAM	: 数据报（用于UDP）
	
	UDP不需要connect，使用不同的数据发送函数和接收函数。
	sendto() - 发送
	recvfrom() - 接收
	无连接的UDP发送数据时无法使用write()
	而接收数据时，在不需要保留发送方通信地址时可以使用read()。

day16 线程
	线程是轻量级的代码并行计数，线程不需要复制进程的资源，而是共享进程的资源，而是
直接共享进程的资源，线程只需要额外的一个栈。因此：很多应用都是使用多线程技术 、
	主流的操作系统支持多进程，每个进程的内部支持多线程，线程可以嵌套。
	
	如何实现代码的并行？
	程序代码执行至少需要CPU（中央处理器）和内存，代码并行需要多个CPU和多段内存。
内存可以分，CPU不可分。大多数系统采用CPU时间片实现代码的并行（伪并行）。首先把
CPU的运行时间分成及小的CPU时间片，然后每个线程拿一片，有时间片的线程就有运行的权
利，但先后次序完全无序的。一轮之后，在重新分配CPU的时间片。
人的感官是需要时间的，假定人的视觉以1毫秒做一个CPU时间片，有2个线程A B C D，每个
线程先拿1毫秒的CPU时间片，当我们看到四个线程是，每个新城都运行了25毫秒。
	
	多线程之间是轮序运行，但每个线程内部都是顺序执行。
	多线程和线程之间是独立的，但互相有影响。
	多线程可以提升程序的效率。
	
	每个进程的内部至少有一个线程，就是main叫主线程。
	主线程一旦结束，进程随之结束，其他线程也随之结束。
	
	Unix有哪些关于线程的API（应用程序接口）
	多线程的开发定义在POSIX规范中，使用pthread.h头文件，所有函数放入libpthread.so中。
	创建线程的函数：
		int pthread_creat()(pthread_t * id, pthread_attr *attr, void*(*task)(void*),
							void* argue)
		参数id用于存储线程ID，每个线程用ID做标识
		attr是线程的属性，默认给0即可。
		task是函数指针，参数和返回值都可以是任意类型
		argue是task的参数，函数指针只能传弟子，而参数用argue传入。
		返回值是错误码，如果没有出错返回0.
		注：线程的函数基本都返回错误码，而不适用errno，因此处理线程的错误码要使
	用strerror()。
	在创建线程时，传输是传递地址，但直接传递整数也可以，在传地址时，注意保证地址
时有效的。空指针、野指针、已经被free()d的堆区指针都是无效的。
	线程可以有返回值，返回值有pthread_join()函数的第二个参数带回。线程返回值类型
是void*，因此参数的类型是void**.

关于函数返回值的一些常识：
	1 返回值类型不能是数组，可以使指针。
	2 可以返回局部变量，不可以返回指向局部变量的指针地址。
	3 static修饰的局部变量地址可以返回。
	线程的退出
		1 正常退出
			在线程的函数中，执行return语句。
			执行pthread_exit(void*)函数
		2 非正常退出
			被其他线程用pthread_cancel()取消
			自身运行出了问题
	注：exit()退出的是进程，不能用于退出线程，否则所有线程全部结束。
	信号退出的是进程，不能退出进程。
day17
	线程的状态 - 分离和非分离
	线程同步技术 - 互斥量（互斥锁）、信号量
	
	现成的资源回收有以下三种可能：
	1 非分离的线程，调用pthread_join()，资源在join()函数结束立即回收。
	2 分离的线程，线程一结束立即回收资源。
	3 非分离的线程，也没有被join()，资源不一定何时回收。
	因此，线程最后处于分离状态或者被join()。
	把线程设置为分离状态，在创建线程以后调用pthread_detach(id)即可，处于deteach状
态的线程join()函数无效。
	
	线程同步技术
		由于同一进程内部的多线程是共享进程的资源，因此可能出现共享数据的冲突。解决
	方案就是把有可能出现冲突的代码改成排队串行（部分串行）。这种技术叫做线程同步技
	术，线程的同步技术有很多种，Uc主要是三种：
		1 互斥量
		2 信号领
		3 条件变量
	注意：线程同步技术会大幅度降低效率，因此要尽可能少用，但如果有共享数据冲突的代
码，一定要使用。
	互斥量 - 又叫互斥锁（mutex）
		pthread_mutex_t lock;
	2 初始化互斥量
		pthread_mutex_init(&lock, 0);
		或在声明的同时用宏初始化
	pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
	这个宏定义只能在声明时使用，不能单独赋值。
	3 给共性数据冲突的代码加锁（串行代码的开始）
		pthread_mutex_lock(&lock);
	4 访问共享数据的代码
	5 解锁（串行代码的结束）
	6 释放互斥量的资源
		pthread_mutex_destroy(&lock)

	信号量也能解决共性数据的冲突问题。
		限号量自身就是一个计数器，可以控制访问共享资源的最大的进程/线程总数。
		信号量的技术如果为1，效果等价于互斥量。
		信号量不属于POSIX，使用semaphore.h使用步骤和互斥量非常类似，但函数不同。
	信号量的使用步骤：
		1 声明限号量	sem_t sem;
		2 初始化		sem_init(&sem, 0, 1);
			其中，第一个参数是信号量的地址；第二个参数表示用于进程还是线程，0表示用于线程；
		第三个参数就是计数的最大值。
		3 计数-1		sem_wait(&sem)
		4 访问共享资源
		5 计数+1		sem_post(&sem);
		6 释放信号量的资源 sem_destory(&sem);
	如果遇到共享冲突，尽量使用互斥量，因为信号量是用于控制访问共享数据的线程总数。
而互斥量和条件变量还可以结合使用。
	
	使用线程同步技术一定要避免 死锁现象。
		pthread_mutex_t lock1, lock2;
	线程a:
		lock(&lock1);
		  ....
		    lock(&lock2);
			 ...
			unlock(&lock2);
		unlock(&lock1);
		ulock
	线程b:
		lock(&lock2);
		  ....
		    lock(&lock1);
			 ...
			unlock(&lock1);
		unlock(&lock2);
	死锁在复杂应用中，不能绝对避免，但有避免死锁的基本原则：
		正向上锁、反向解锁、不要回调

综合案例：
	基于TCP的聊天室，支持多用户同时登陆服务器进行聊天。
	socket编程，做一对多的通信，必然要用到多线程，保证多个客户登陆服务器进行聊天。
具体实现：
	客户端：
		1 用户需要登陆，登陆是需要输入一个昵称，不需要判断昵称是否重复。
		2 用户登陆后连接服务器，进入聊天室。
		3 用户可以输入聊天信息，也可以接受到别人的聊天信息。
		4 用户可以输入一个特殊的单词 代表退出聊天室。
	服务器端：
		1 启动服务器，开放端口。
		2 等待客户端的连接，每连接上来一个客户端就启动一个线程。
		3 在线程中与客户进行交互，交互交互过程：
			若果有客户端登录、退出、提交聊天
			服务器端都要报这些信息发给每个客户端。
TCP通信步骤：
服务器：
	1 创建socket
	2 准备网络通信地址 sockaddr_in
	3 绑定socket和网络通信地址 bind()
	4 设置监听 listen()
	5 等待客户端连接accept() 
客户端：
	1 创建socket
	2 准备网络通信地址（服务器的IP和端口
	3 连接服务器 connect()
-------------------------------
	tcp通信相关函数：
	send/recv
	int send(sockfd, buf, len, flags);
	如果flags置0，则功能和write一样。

	recev函数的返回值：
	>0 返回接收到的字节数
	<0 接收出错
	=0 表示TCP的另一端主动断开连接。

Oracle
plsql

oracle	数据库的一种

一、DB
DMBS	数据库管理系统
DB		数据库

RDBMS	关系型数据库管理系统
RDB		关系型数据库
		基于二维表的数据库

SQL		struct query language

二、二维表
table
表头
行
列
字段
字段值
一行数据

三、现在主流的数据库管理系统
商业
现在主流的数据库管理系统
	oracle(甲骨文)	oracke9i oracle10g oracke11g
	IBM		DB2
	MIC		aqlserver
非商业型数据库
	SUN		mysql
			JAVA
			Unix

四、SQL语句的分类
	4.1 select	语句
		select
	4.2 DDL		数据定义语言
		create	table	建表
		drop	table	删表
		alter	table	该表
	4.3	DML		数据操作语言
		insert
		delete
		update
	4.4	TCL		事物控制语言
		commit
		rollback
		savepoint
	4.5	DCL		数据控制语言
		grant
		revoke
五、操作数据库
	5.1 远程登录服务器
		telnet	IP
		telnet	192.168.0.26
		telnet	192.168.0.23
	5.2	用户名：openlab
		用户密码：open123
	5.3	使用sqlplus 连接数据库
		sqlplus
		sqlplus
		open123






















		